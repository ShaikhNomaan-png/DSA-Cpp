#include <iostream>
#include <vector>

using namespace std;

// Function to generate the power set
vector<vector<int>> powerSet(const vector<int>& set) {
    int n = set.size();
    // Total number of subsets is 2^n
    int powerSetSize = 1 << n; 
    vector<vector<int>> powerSet; // To hold all subsets

    // Generate each subset
    for (int i = 0; i < powerSetSize; ++i) {
        vector<int> subset; // Current subset

        // Check each bit position
        for (int j = 0; j < n; ++j) {
            // If the j-th bit in i is set, include set[j]
            if (i & (1 << j)) {
                subset.push_back(set[j]);
            }
        }

        powerSet.push_back(subset); // Add the current subset to the power set
    }

    return powerSet;
}

int main() {
    vector<int> set = {1, 2, 3, 4}; // Example set
    vector<vector<int>> result = powerSet(set);

    // Display the power set
    cout << "Power Set:\n";
    for (const auto& subset : result) {
        cout << "{ ";
        for (int elem : subset) {
            cout << elem << " ";
        }
        cout << "}\n";
    }

    return 0;
}


/*  Output Explanation
When you run the program with the input set ({1, 2, 3}):

Total Subsets Calculation:

For a set of size (3), the number of subsets is (2^3 = 8).
The subsets will be generated by iterating from (0) (000 in binary) to (7) (111 in binary).
Subset Generation:

For (i = 0 (000)): No bits are set → Subset: ({})
For (i = 1 (001)): 1st bit set → Subset: ({1})
For (i = 2 (010)): 2nd bit set → Subset: ({2})
For (i = 3 (011)): 1st and 2nd bits set → Subset: ({1, 2})
For (i = 4 (100)): 3rd bit set → Subset: ({3})
For (i = 5 (101)): 1st and 3rd bits set → Subset: ({1, 3})
For (i = 6 (110)): 2nd and 3rd bits set → Subset: ({2, 3})
For (i = 7 (111)): All bits set → Subset: ({1, 2, 3})
Final Output:

text

Power Set:
{ }
{ 1 }
{ 2 }
{ 1 2 }
{ 3 }
{ 1 3 }
{ 2 3 }
{ 1 2 3 }
Conclusion
The power set is an essential concept in combinatorics and can be effectively generated using bit manipulation techniques. By representing each subset as a bitmask, we can efficiently explore all combinations of the set's elements. This approach demonstrates the power and utility of bit manipulation in generating combinatorial structures.

Feel free to ask if you have further questions or need additional examples!
*/